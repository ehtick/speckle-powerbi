// function for extracting and flattening properties from Speckle objects
(inputRecord as record) as record =>
let
    // define excluded paths
    ExcludedPaths = {
        "Composite Structure",
        "Material Quantities", 
        "Parameters.Type Parameters.Structure"
    },
    
    IsExcludedPath = (path as text) as logical =>
        List.AnyTrue(
            List.Transform(
                ExcludedPaths,
                (excludedPath) => Text.StartsWith(path, excludedPath)
            )
        ),
    
    // helper function to process name-value objects
    ProcessNameValueObject = (obj as record) as record =>
        let
            // Assert that the object has required fields
            _ = if not (Record.HasFields(obj, {"name"}) and Record.HasFields(obj, {"value"})) then
                error [
                    Reason = "Invalid Name-Value Object",
                    Message = "Object must have both 'name' and 'value' fields"
                ]
            else
                null,
                
            BaseName = obj[name],
            BaseValue = obj[value],
            
            // only extract name and value, ignore units and other fields
            Result = Record.FromList({BaseValue}, {BaseName})
        in
            Result,
    
    // Helper function to process direct key-value objects
    ProcessDirectKeyValueObject = (obj as record) as record =>
        let
            // Assert that input is a record
            _ = if not Value.Is(obj, type record) then
                error [
                    Reason = "Invalid Input Type",
                    Message = "Expected record for direct key-value processing"
                ]
            else
                null,
                
            // Extract all primitive key-value pairs
            PrimitiveFields = List.Transform(
                Record.FieldNames(obj),
                (fieldName) => 
                    let
                        fieldValue = Record.Field(obj, fieldName)
                    in
                        if not Type.Is(Value.Type(fieldValue), type record) then
                            Record.FromList({fieldValue}, {fieldName})
                        else
                            []
            ),
            
            // Filter out empty records and combine
            FilteredFields = List.Select(PrimitiveFields, (rec) => Record.FieldCount(rec) > 0),
            Result = List.Accumulate(
                FilteredFields,
                [],
                (state, current) => Record.Combine({state, current})
            )
        in
            Result,
    
    // Helper functions for type checking
    HasDirectKeyValuePattern = (obj as record) as logical =>
        List.AllTrue(
            List.Transform(
                Record.FieldValues(obj),
                (value) => not Type.Is(Value.Type(value), type record)
            )
        ),
    
    IsNestedContainer = (obj as record) as logical =>
        List.AnyTrue(
            List.Transform(
                Record.FieldValues(obj),
                (value) => Type.Is(Value.Type(value), type record)
            )
        ),
    
    // Main processing function with path tracking
    ProcessField = (fieldName as text, fieldValue as any, currentPath as text) as record =>
        let
            fieldPath = if currentPath = "" then fieldName else currentPath & "." & fieldName
        in
            if IsExcludedPath(fieldPath) then
                // Return empty record for excluded paths
                []
            else if Type.Is(Value.Type(fieldValue), type record) then
                if Record.HasFields(fieldValue, {"name", "value"}) then
                    ProcessNameValueObject(fieldValue)
                else if HasDirectKeyValuePattern(fieldValue) then
                    ProcessDirectKeyValueObject(fieldValue)
                else if IsNestedContainer(fieldValue) then
                    // Recursive call for nested containers
                    @ProcessRecord(fieldValue, fieldPath)
                else
                    // Unknown record type, skip
                    []
            else
                // Primitive value
                Record.FromList({fieldValue}, {fieldName}),
    
    // Process entire record recursively
    ProcessRecord = (record as record, currentPath as text) as record =>
        let
            // Assert that input is a record
            _ = if not Value.Is(record, type record) then
                error [
                    Reason = "Invalid Record Type",
                    Message = "Expected record for processing, but received: " & Text.From(Value.Type(record))
                ]
            else
                null,
                
            ProcessedFields = List.Transform(
                Record.FieldNames(record),
                (fieldName) => ProcessField(fieldName, Record.Field(record, fieldName), currentPath)
            ),
            FilteredFields = List.Select(ProcessedFields, (rec) => Record.FieldCount(rec) > 0),
            CombinedRecord = List.Accumulate(
                FilteredFields,
                [],
                (state, current) => Record.Combine({state, current})
            )
        in
            CombinedRecord,
    
    // Assert that input is a record before processing
    _ = if not Value.Is(inputRecord, type record) then
        error [
            Reason = "Invalid Input Type",
            Message = "Input must be a record, but received: " & Text.From(Value.Type(inputRecord))
        ]
    else
        null,
    
    // Start processing from root
    Result = ProcessRecord(inputRecord, "")
in
    Result 